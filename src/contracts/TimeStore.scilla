(* A two-part timekeeper contract containing... *)
(*  - A Merkle Root store for A remote calendar server *)
(*  - A validated store of the latest NIST randomness beacon (future) *)

(* @note: Owner cannot be changed, but delegated responsibilities are updatable. *)
(* Responsibilities: Chronos (randomness oracle) and Kairos (timestamp calendar anchor) *)
scilla_version 0


(***************************************************)
(*               Associated library                *)
(***************************************************)
library TimeStore

let one_msg =
  fun (msg: Message) =>
  let nil_msg = Nil {Message} in
  Cons {Message} msg nil_msg

(* Error events *)
type Error =
  | CodeNotKairos
  | CodeNotChronos

let make_error =
  fun (result : Error) =>
    let result_code = 
      match result with
      | CodeNotKairos  => Int32 -1
      | CodeNotChronos => Int32 -2
      end
    in
    { _exception : "Error"; code : result_code }

(* error codes library *)
let code_success = Uint32 0
let code_not_authorized = Uint32 2
let code_invalid_params = Uint32 3

(***************************************************)
(*             The contract definition             *)
(***************************************************)
contract TimeStore
(
  chronos: ByStr20,
  kairos: ByStr20
)

(*Store of Data Timestamp's merkle root*)
field latestMerkleRoot: String = ""

(*Store of NIST's latest randomness*)
field latestNISTRandom: String = ""

procedure ThrowError(err : Error)
  e = make_error err;
  throw e
end

(* @notice: Allows a `_sender` to update the merkle root from a remote Calendar server *)
(* @dev   : Access controls are simply if _sender is the set server key *)

transition updateRoot(new_root: String)
   
    (* Access Control  *)
    permitted = builtin eq _sender kairos;
    
    match permitted with
    | False =>
        (* the attempt to update root was rejected *)
        err = CodeNotKairos;
        ThrowError err
    | True =>
        (* An updated merkle root can be used to upgrade a proof transparently - there is no need to log past roots *)
        latestMerkleRoot := new_root;
        e = {_eventname: "RootUpdated"; new_root: new_root};
        event e
    end


end




(* @notice: Allows a `_sender` to update the NIST randomness string *)
(* @dev   : Access controls are simply if _sender is the authorized server key *)

transition updateRandom(new_random: String)
   
    (* Access Control  *)
    permitted = builtin eq _sender chronos;
    match permitted with
    | False =>
        (* the attempt to update the random beacon was rejected *)
        err = CodeNotChronos;
        ThrowError err
    | True =>
        (* Update the randomness beacon *)
        (* FUTURE: Require proof from calendar service for trustable oracle *)
        latestNISTRandom := new_random;
        e = {_eventname: "RandomUpdated"; new_random: new_random};
        event e
    end


end
